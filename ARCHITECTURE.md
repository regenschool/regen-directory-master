# Architecture de l'Application - Regen School

**Date** : 2025-10-12  
**Version** : 2.0 - Architecture Normalis√©e et Scalable

---

## üèóÔ∏è Vue d'Ensemble

Cette application est construite sur une architecture **normalis√©e et relationnelle** avec :
- **Frontend** : React + TypeScript + Tailwind CSS
- **Backend** : Lovable Cloud (Supabase)
- **Base de donn√©es** : PostgreSQL avec relations normalis√©es
- **Authentification** : Supabase Auth avec gestion des r√¥les

---

## üìä Architecture Base de Donn√©es

### Principe Fondamental : Normalisation Compl√®te

Toutes les tables utilisent des **foreign keys (UUID)** au lieu de texte libre :
- `students` ‚Üí `classes.id`, `levels.id`, `school_years.id`, `teachers.user_id`
- `subjects` ‚Üí `classes.id`, `academic_periods.id`, `school_years.id`, `teachers.user_id`
- `grades` ‚Üí `classes.id`, `academic_periods.id`

**Compatibilit√© ascendante** : Les colonnes `TEXT` originales (`class_name`, `teacher_name`, etc.) sont pr√©serv√©es pour compatibilit√©.

### Tables R√©f√©rentielles (Master Data)

#### 1. `school_years` - Ann√©es Scolaires
```sql
id: UUID PRIMARY KEY
label: TEXT NOT NULL UNIQUE -- "2024-2025"
start_date: DATE
end_date: DATE
is_active: BOOLEAN DEFAULT FALSE
```

#### 2. `academic_periods` - P√©riodes Acad√©miques (Semestres)
```sql
id: UUID PRIMARY KEY
label: TEXT NOT NULL -- "Semestre 1", "Semestre 2", "Q1", "Q2"...
school_year_id: UUID REFERENCES school_years(id)
start_date: DATE
end_date: DATE
is_active: BOOLEAN DEFAULT FALSE
```

#### 3. `levels` - Niveaux d'√âtude
```sql
id: UUID PRIMARY KEY
name: TEXT NOT NULL UNIQUE -- "B1", "B2", "B3", "M1", "M2"
is_active: BOOLEAN DEFAULT TRUE
```

#### 4. `classes` - Classes
```sql
id: UUID PRIMARY KEY
name: TEXT NOT NULL UNIQUE -- "B3", "IMA", "IMB", "M1A"
level: TEXT -- Niveau associ√© (peut √™tre NULL)
capacity: INTEGER
is_active: BOOLEAN DEFAULT TRUE
```

**Index** : `idx_classes_name` sur `name` (recherches fr√©quentes)

#### 5. `teachers` - Enseignants ‚ö†Ô∏è **ARCHITECTURE IMPORTANTE**

**Principe** : Un enseignant = un utilisateur avec le r√¥le `teacher`

```sql
-- PRIMARY KEY = user_id (pas d'id s√©par√©)
user_id: UUID PRIMARY KEY REFERENCES auth.users(id)
full_name: TEXT NOT NULL
email: TEXT -- Synchronis√© AUTO depuis auth.users via trigger
phone: TEXT
created_at: TIMESTAMPTZ
updated_at: TIMESTAMPTZ
```

**Triggers automatiques** :
- `sync_teacher_role()` : Cr√©e automatiquement un `user_role` avec `role = 'teacher'` lors de l'INSERT
- `sync_teacher_email()` : Synchronise l'email depuis `auth.users` avant INSERT/UPDATE

**RLS Policies** :
- `SELECT` : enseignants (role teacher) + admins
- `UPDATE` : enseignant lui-m√™me + admins
- `INSERT/DELETE` : admins uniquement

---

### Tables Transactionnelles

#### 6. `students` - √âtudiants
```sql
id: UUID PRIMARY KEY
first_name: TEXT NOT NULL
last_name: TEXT NOT NULL
birth_date: DATE
age: INTEGER (calcul√©)
photo_url: TEXT
special_needs: TEXT
academic_background: TEXT
company: TEXT

-- Foreign Keys (Normalis√©)
class_id: UUID REFERENCES classes(id)
level_id: UUID REFERENCES levels(id)
school_year_id: UUID REFERENCES school_years(id)
assigned_teacher_id: UUID REFERENCES teachers(user_id) ON DELETE SET NULL

-- Compatibilit√© (ancien TEXT)
class_name: TEXT NOT NULL
teacher_id: UUID -- D√©pr√©ci√©, utiliser assigned_teacher_id
```

**Index** :
- `idx_students_class` sur `class_id`
- `idx_students_level` sur `level_id`
- `idx_students_school_year` sur `school_year_id`

#### 7. `subjects` - Mati√®res
```sql
id: UUID PRIMARY KEY
subject_name: TEXT NOT NULL
teacher_name: TEXT NOT NULL -- Compatibilit√©
semester: TEXT NOT NULL
school_year: TEXT NOT NULL

-- Foreign Keys (Normalis√©)
teacher_fk_id: UUID REFERENCES teachers(user_id) ON DELETE SET NULL
class_fk_id: UUID REFERENCES classes(id)
academic_period_id: UUID REFERENCES academic_periods(id)
school_year_fk_id: UUID REFERENCES school_years(id)

-- Compatibilit√©
class_name: TEXT NOT NULL
teacher_id: UUID
teacher_email: TEXT
```

**Index** :
- `idx_subjects_teacher` sur `teacher_fk_id`
- `idx_subjects_class` sur `class_fk_id`
- `idx_subjects_period` sur `academic_period_id`
- `idx_subjects_lookup` composite sur `class_name, school_year, semester`

#### 8. `grades` - Notes
```sql
id: UUID PRIMARY KEY
student_id: UUID NOT NULL
subject: TEXT NOT NULL
assessment_name: TEXT
assessment_type: ENUM(participation_individuelle, oral_groupe, oral_individuel, ecrit_groupe, ecrit_individuel, memoire, autre)
assessment_custom_label: TEXT
grade: NUMERIC NOT NULL
max_grade: NUMERIC NOT NULL DEFAULT 20
weighting: NUMERIC NOT NULL DEFAULT 1
appreciation: TEXT
is_absent: BOOLEAN DEFAULT FALSE
teacher_id: UUID NOT NULL
teacher_name: TEXT
school_year: TEXT
semester: TEXT
class_name: TEXT NOT NULL

-- Foreign Keys (Normalis√©)
class_fk_id: UUID REFERENCES classes(id)
academic_period_fk_id: UUID REFERENCES academic_periods(id)
```

**Index** :
- `idx_grades_student` sur `student_id`
- `idx_grades_teacher` sur `teacher_id`
- `idx_grades_class` sur `class_fk_id`
- `idx_grades_lookup` composite sur `class_name, subject, school_year, semester`
- `idx_grades_assessment` composite sur `assessment_name, assessment_type`

---

### Vues Enrichies (Performance)

#### `v_students_enriched`
```sql
SELECT 
  s.*,
  c.name as class_name_from_ref,
  c.level as class_level,
  l.name as level_name,
  sy.label as school_year_label,
  t.full_name as assigned_teacher_name,
  t.email as assigned_teacher_email
FROM students s
LEFT JOIN classes c ON s.class_id = c.id
LEFT JOIN levels l ON s.level_id = l.id
LEFT JOIN school_years sy ON s.school_year_id = sy.id
LEFT JOIN teachers t ON s.assigned_teacher_id = t.user_id
```

**IMPORTANT** : Vue avec `SECURITY INVOKER` pour respecter RLS

#### `v_grades_enriched`
```sql
SELECT 
  g.*,
  s.first_name as student_first_name,
  s.last_name as student_last_name,
  c.name as class_name_from_ref,
  ap.label as academic_period_label,
  sy.label as school_year_from_ref,
  t.full_name as teacher_full_name,
  t.email as teacher_email_from_ref
FROM grades g
LEFT JOIN students s ON g.student_id = s.id
LEFT JOIN classes c ON g.class_fk_id = c.id
LEFT JOIN academic_periods ap ON g.academic_period_fk_id = ap.id
LEFT JOIN school_years sy ON ap.school_year_id = sy.id
LEFT JOIN teachers t ON g.teacher_id = t.user_id
```

---

## üîê Gestion des Utilisateurs et R√¥les

### Architecture des R√¥les

#### Enum `app_role`
```sql
CREATE TYPE app_role AS ENUM ('admin', 'moderator', 'teacher');
```

#### Table `user_roles`
```sql
id: UUID PRIMARY KEY
user_id: UUID REFERENCES auth.users(id)
role: app_role NOT NULL
UNIQUE(user_id, role)
```

**Fonction de v√©rification** :
```sql
has_role(_user_id UUID, _role app_role) RETURNS BOOLEAN
-- SECURITY DEFINER pour √©viter r√©cursion RLS
```

### üéì Principe: Enseignant = Utilisateur avec R√¥le

**Un enseignant n'est PAS une entit√© s√©par√©e**, c'est :
1. Un utilisateur dans `auth.users`
2. Avec un enregistrement dans `teachers` (extension de profil)
3. Et un r√¥le `teacher` dans `user_roles`

**Workflow de cr√©ation** :
```
1. Admin cr√©e un compte utilisateur ‚Üí auth.users
2. Admin ins√®re dans `teachers` avec user_id
3. Trigger `sync_teacher_role` cr√©e automatiquement le role 'teacher'
4. Trigger `sync_teacher_email` synchronise l'email depuis auth.users
```

**Synchronisation automatique** :
- `INSERT INTO teachers` ‚Üí Cr√©e `user_roles` avec `role = 'teacher'`
- `DELETE FROM teachers` ‚Üí Supprime `user_roles` avec `role = 'teacher'`
- Email toujours synchronis√© depuis `auth.users`

---

## üîÑ Migrations et Int√©grit√©

### Compatibilit√© Ascendante

Toutes les anciennes colonnes TEXT sont pr√©serv√©es :
- `students.class_name` (parall√®le √† `class_id`)
- `subjects.teacher_name` (parall√®le √† `teacher_fk_id`)
- `grades.class_name` (parall√®le √† `class_fk_id`)

**Strat√©gie** :
1. Nouvelles relations utilisent les FK
2. Anciennes colonnes restent pour compatibilit√©
3. Migration progressive des donn√©es

### Triggers de Synchronisation

#### `sync_teacher_role()`
Synchronise automatiquement `teachers` ‚Üî `user_roles` :
- INSERT teachers ‚Üí INSERT user_roles (role = 'teacher')
- DELETE teachers ‚Üí DELETE user_roles (role = 'teacher')

#### `sync_teacher_email()`
Synchronise automatiquement `teachers.email` ‚Üê `auth.users.email` :
- Avant INSERT/UPDATE teachers
- Email devient lecture seule dans l'application

---

## üìÅ Structure du Code Frontend

### Hooks Personnalis√©s

#### `useReferentials.ts`
Gestion centralis√©e des r√©f√©rentiels :
- `useSchoolYears()`, `useAcademicPeriods()`, `useClasses()`, `useLevels()`
- Mutations avec invalidation de cache optimis√©e

#### `useTeachers.ts` ‚ö†Ô∏è **ARCHITECTURE MISE √Ä JOUR**
Gestion des enseignants-utilisateurs :
```typescript
export type Teacher = {
  user_id: string; // PRIMARY KEY (pas d'id)
  full_name: string;
  email: string | null; // Lecture seule
  phone: string | null;
};

useAddTeacher() // N√©cessite user_id existant
useUpdateTeacher() // email en lecture seule
useDeleteTeacher() // Supprime aussi le r√¥le 'teacher'
syncTeacherFromAuth() // Helper pour premier login
```

#### `useStudents.ts`
Gestion des √©tudiants avec relations :
```typescript
type Student = {
  id: string;
  class_id: string | null; // FK normalis√©e
  level_id: string | null;
  school_year_id: string | null;
  assigned_teacher_id: string | null; // FK vers teachers(user_id)
  class_name: string; // Compatibilit√©
};
```

#### `useGrades.ts`
Gestion des notes avec bug-fix :
```typescript
useAddGrade() // ‚úÖ Check-then-update/insert (pas de onConflict)
```

### Composants Settings

- `SchoolYearsManager` : CRUD ann√©es scolaires
- `AcademicPeriodsManager` : CRUD p√©riodes acad√©miques
- `ClassesManager` : CRUD classes
- `LevelsManager` : CRUD niveaux
- `TeachersManager` : CRUD enseignants (utilisateurs avec r√¥le teacher)
- `SyncReferentialsButton` : Synchronisation manuelle

---

## üêõ Bugs Historiques (DOCUMENTATION CRITIQUE)

Voir `BUGS_FIXES.md` pour l'historique complet.

### Bug #1 : Duplication des Notes ‚ö†Ô∏è **CRITIQUE**

**Cause** : Utilisation de `.upsert()` avec `onConflict` (non support√© par Supabase)

**Solution** :
```typescript
// ‚ùå INCORRECT
await supabase.from("grades").upsert(data, { onConflict: '...' });

// ‚úÖ CORRECT
const { data: existing } = await supabase.from('grades')
  .select('id').eq('student_id', id).maybeSingle();

if (existing) {
  await supabase.from('grades').update(data).eq('id', existing.id);
} else {
  await supabase.from('grades').insert([data]);
}
```

**Fichiers concern√©s** :
- `src/components/GradeEntryDialog.tsx`
- `src/hooks/useGrades.ts` (r√©introduit puis re-corrig√© le 2025-10-12)

---

## üß™ Tests de Non-R√©gression

Voir `TESTS_NON_REGRESSION.md` pour le plan complet.

**Derniers r√©sultats** (2025-10-12) :
- ‚úÖ 12/16 tests valid√©s automatiquement (75%)
- ‚úÖ Bug #1 : Z√âRO doublon d√©tect√©
- ‚úÖ Migration FK : 100% des √©tudiants migr√©s
- ‚úÖ Vues enrichies : parfaitement synchronis√©es

---

## üìö Bonnes Pratiques

### Supabase
- ‚ö†Ô∏è **NE JAMAIS** utiliser `.upsert()` avec `onConflict`
- ‚úÖ Toujours utiliser `.maybeSingle()` pour v√©rifications
- ‚úÖ Utiliser des FK UUID, pas du texte
- ‚úÖ Cr√©er des index sur les colonnes de jointure

### Enseignants
- ‚ö†Ô∏è Un enseignant = un utilisateur avec r√¥le 'teacher'
- ‚úÖ Utiliser `teachers.user_id` comme PRIMARY KEY
- ‚úÖ L'email est en lecture seule (sync auto)
- ‚úÖ Les triggers g√®rent automatiquement les r√¥les

### Architecture
- ‚úÖ Normalisation > D√©normalisation
- ‚úÖ Pr√©server compatibilit√© ascendante
- ‚úÖ Documenter tous les bugs dans BUGS_FIXES.md
- ‚úÖ Tester avant de merger

---

*Derni√®re mise √† jour : 2025-10-12*
